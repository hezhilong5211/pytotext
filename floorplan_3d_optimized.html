<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Då¹³é¢å›¾ - é«˜æ€§èƒ½ä¼˜åŒ–ç‰ˆï¼ˆæ”¯æŒ100+æˆ¿é—´ï¼‰</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Microsoft YaHei", sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        .toolbar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.4) 100%);
            backdrop-filter: blur(10px);
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 1000;
        }

        .toolbar h1 {
            color: white;
            font-size: 24px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toolbar-right {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .room-count {
            background: rgba(255,255,255,0.15);
            padding: 10px 20px;
            border-radius: 20px;
            color: white;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .room-count input {
            width: 60px;
            background: rgba(255,255,255,0.2);
            border: none;
            padding: 5px 10px;
            border-radius: 8px;
            color: white;
            text-align: center;
            font-weight: bold;
        }

        .search-box {
            position: relative;
        }

        .search-box input {
            padding: 12px 45px 12px 20px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 25px;
            width: 280px;
            font-size: 14px;
            outline: none;
            background: rgba(255,255,255,0.15);
            color: white;
        }

        .search-box input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .search-box button {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            cursor: pointer;
            color: white;
            font-size: 16px;
        }

        .control-panel {
            position: absolute;
            right: 30px;
            bottom: 30px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 100;
        }

        .control-btn {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, rgba(102,126,234,0.9), rgba(118,75,162,0.9));
            backdrop-filter: blur(10px);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            transition: all 0.3s;
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }

        .control-btn:hover {
            transform: scale(1.15);
        }

        .info-panel {
            position: absolute;
            left: 30px;
            bottom: 30px;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(20px);
            padding: 24px;
            border-radius: 16px;
            color: white;
            min-width: 320px;
            border: 2px solid rgba(102,126,234,0.5);
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
            display: none;
        }

        .info-panel.show {
            display: block;
        }

        .info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 2px solid rgba(102,126,234,0.5);
        }

        .info-title {
            font-size: 22px;
            font-weight: 700;
            color: #ffd700;
        }

        .close-info {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
        }

        .info-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
        }

        .info-label {
            color: #aaa;
            font-size: 13px;
        }

        .info-value {
            color: white;
            font-weight: 600;
        }

        .stats {
            position: absolute;
            top: 100px;
            right: 30px;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(20px);
            padding: 16px 20px;
            border-radius: 12px;
            color: white;
            border: 2px solid rgba(102,126,234,0.5);
            font-size: 13px;
            font-family: 'Courier New', monospace;
            min-width: 200px;
        }

        .stats-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #667eea;
            font-size: 14px;
        }

        .stats div {
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
        }

        .stats .value {
            color: #4ade80;
            font-weight: bold;
        }

        .hints {
            position: absolute;
            top: 100px;
            left: 30px;
            background: rgba(0,0,0,0.9);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 12px;
            color: white;
            border: 2px solid rgba(102,126,234,0.5);
            max-width: 300px;
        }

        .hints-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 12px;
            color: #667eea;
        }

        .hint-item {
            margin-bottom: 10px;
            font-size: 13px;
            color: #ddd;
        }

        .hide-hints {
            margin-top: 12px;
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            text-align: center;
            z-index: 9999;
        }

        .loading-bar {
            width: 300px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            margin-top: 20px;
            overflow: hidden;
        }

        .loading-progress {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <!-- åŠ è½½åŠ¨ç”» -->
        <div class="loading" id="loading">
            <div>âš¡ æ­£åœ¨ç”Ÿæˆ3Dåœºæ™¯...</div>
            <div id="loadingText">å‡†å¤‡ä¸­</div>
            <div class="loading-bar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
        </div>

        <!-- é¡¶éƒ¨å·¥å…·æ  -->
        <div class="toolbar">
            <h1>
                <span>ğŸ—ï¸</span>
                <span>3Då¹³é¢å›¾ - é«˜æ€§èƒ½ç‰ˆ</span>
            </h1>
            <div class="toolbar-right">
                <div class="room-count">
                    <span>æˆ¿é—´æ•°é‡:</span>
                    <input type="number" id="roomCountInput" value="100" min="10" max="500">
                    <button onclick="regenerateRooms()" style="background: #4ade80; border: none; padding: 8px 16px; border-radius: 8px; color: white; cursor: pointer; font-weight: bold;">ç”Ÿæˆ</button>
                </div>
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="æœç´¢æˆ¿é—´ (å¦‚: R-050)..." onkeyup="if(event.key==='Enter') performSearch()">
                    <button onclick="performSearch()">ğŸ”</button>
                </div>
            </div>
        </div>

        <!-- æ€§èƒ½ç»Ÿè®¡ -->
        <div class="stats">
            <div class="stats-title">âš¡ æ€§èƒ½ç›‘æ§</div>
            <div><span>FPS:</span> <span class="value" id="fps">60</span></div>
            <div><span>æˆ¿é—´æ•°:</span> <span class="value" id="roomCount">0</span></div>
            <div><span>æ¸²æŸ“å¯¹è±¡:</span> <span class="value" id="objects">0</span></div>
            <div><span>ä¸‰è§’é¢:</span> <span class="value" id="triangles">0</span></div>
            <div><span>å†…å­˜:</span> <span class="value" id="memory">0 MB</span></div>
        </div>

        <!-- æ“ä½œæç¤º -->
        <div class="hints" id="hints">
            <div class="hints-title">ğŸ’¡ æ“ä½œæŒ‡å—</div>
            <div class="hint-item">ğŸ–±ï¸ å·¦é”®æ‹–æ‹½ - æ—‹è½¬è§†è§’</div>
            <div class="hint-item">ğŸ–±ï¸ å³é”®æ‹–æ‹½ - å¹³ç§»åœºæ™¯</div>
            <div class="hint-item">ğŸ–±ï¸ æ»šè½® - ç¼©æ”¾</div>
            <div class="hint-item">ğŸ–±ï¸ ç‚¹å‡»æˆ¿é—´ - æŸ¥çœ‹è¯¦æƒ…</div>
            <div class="hint-item">âš¡ æ”¯æŒ100+æˆ¿é—´æµç•…è¿è¡Œ</div>
            <button class="hide-hints" onclick="toggleHints()">æˆ‘çŸ¥é“äº†</button>
        </div>

        <!-- æ§åˆ¶é¢æ¿ -->
        <div class="control-panel">
            <button class="control-btn" onclick="resetCamera()" title="é‡ç½®è§†è§’">ğŸ¯</button>
            <button class="control-btn" onclick="toggleWireframe()" title="çº¿æ¡†æ¨¡å¼">ğŸ“</button>
            <button class="control-btn" onclick="flyThroughRooms()" title="è‡ªåŠ¨å·¡èˆª">âœˆï¸</button>
        </div>

        <!-- ä¿¡æ¯é¢æ¿ -->
        <div class="info-panel" id="infoPanel">
            <div class="info-header">
                <div class="info-title" id="infoTitle">æˆ¿é—´ä¿¡æ¯</div>
                <button class="close-info" onclick="closeInfoPanel()">Ã—</button>
            </div>
            <div class="info-content" id="infoContent"></div>
        </div>
    </div>

    <!-- Three.js r128 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer, controls;
        let raycaster, mouse;
        let rooms = [];
        let mergedMesh = null; // åˆå¹¶åçš„ç½‘æ ¼
        let showWireframe = false;
        let roomData = {};
        let flyThroughActive = false;

        // æ€§èƒ½ä¼˜åŒ–é…ç½®
        const OPTIMIZATION_CONFIG = {
            useMergedGeometry: true,  // ä½¿ç”¨åˆå¹¶å‡ ä½•ä½“
            enableShadows: false,      // å…³é—­é˜´å½±ï¼ˆæ€§èƒ½æå‡å·¨å¤§ï¼‰
            useInstancedMesh: false,   // ä½¿ç”¨å®ä¾‹åŒ–ç½‘æ ¼
            lodEnabled: true,          // ä½¿ç”¨LODç»†èŠ‚å±‚æ¬¡
            maxRooms: 500             // æœ€å¤§æˆ¿é—´æ•°
        };

        // æˆ¿é—´ç±»å‹é…ç½®
        const ROOM_TYPES = [
            { type: 'åŠå…¬å®¤', color: 0x42a5f5, probability: 0.4 },
            { type: 'ä¼šè®®å®¤', color: 0x66bb6a, probability: 0.2 },
            { type: 'åŠŸèƒ½åŒº', color: 0xef5350, probability: 0.15 },
            { type: 'è®¾å¤‡åŒº', color: 0xffa726, probability: 0.1 },
            { type: 'å…¬å…±åŒºåŸŸ', color: 0xab47bc, probability: 0.15 }
        ];

        // ==================== åˆå§‹åŒ– ====================
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 80, 200);

            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(60, 50, 60);

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance" // é«˜æ€§èƒ½æ¨¡å¼
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶åƒç´ æ¯”
            
            if (OPTIMIZATION_CONFIG.enableShadows) {
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.BasicShadowMap; // ä½¿ç”¨åŸºç¡€é˜´å½±ï¼ˆæ›´å¿«ï¼‰
            }
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // æ·»åŠ æ§åˆ¶å™¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 10;
            controls.maxDistance = 150;

            // å°„çº¿æ£€æµ‹
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // æ·»åŠ å…‰ç…§
            addLights();
            createFloor();
            
            // ç”Ÿæˆæˆ¿é—´
            const initialRoomCount = parseInt(document.getElementById('roomCountInput').value) || 100;
            generateRooms(initialRoomCount);

            // ç½‘æ ¼è¾…åŠ©
            const gridHelper = new THREE.GridHelper(200, 100, 0x667eea, 0x444444);
            gridHelper.material.opacity = 0.3;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);

            // éšè—åŠ è½½åŠ¨ç”»
            setTimeout(() => {
                document.getElementById('loading').style.display = 'none';
            }, 500);

            animate();
        }

        function addLights() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            // åŠçƒå…‰ï¼ˆæ¨¡æ‹Ÿå¤©ç©ºå’Œåœ°é¢åå°„ï¼‰
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
            scene.add(hemisphereLight);

            // æ–¹å‘å…‰
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(50, 80, 50);
            scene.add(directionalLight);

            // å½©è‰²ç‚¹å…‰æº
            const pointLight = new THREE.PointLight(0x667eea, 0.3, 100);
            pointLight.position.set(30, 20, 30);
            scene.add(pointLight);
        }

        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(200, 200);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x0f3460,
                roughness: 0.9,
                metalness: 0.1
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = OPTIMIZATION_CONFIG.enableShadows;
            scene.add(floor);
        }

        // ==================== é«˜æ€§èƒ½æˆ¿é—´ç”Ÿæˆ ====================
        function generateRooms(count) {
            console.log(`ğŸš€ å¼€å§‹ç”Ÿæˆ ${count} ä¸ªæˆ¿é—´...`);
            const startTime = performance.now();
            
            // æ¸…é™¤æ—§æˆ¿é—´
            clearRooms();
            
            // ç”Ÿæˆæˆ¿é—´æ•°æ®
            roomData = {};
            const roomsPerRow = Math.ceil(Math.sqrt(count));
            const spacing = 8;
            const roomWidth = 6;
            const roomDepth = 5;
            const roomHeight = 3;
            
            for (let i = 0; i < count; i++) {
                const row = Math.floor(i / roomsPerRow);
                const col = i % roomsPerRow;
                const x = (col - roomsPerRow / 2) * spacing;
                const z = (row - roomsPerRow / 2) * spacing;
                
                // éšæœºé€‰æ‹©æˆ¿é—´ç±»å‹
                const roomType = getRandomRoomType();
                const roomId = `R-${String(i + 1).padStart(3, '0')}`;
                
                roomData[roomId] = {
                    id: roomId,
                    name: `${roomType.type}${i + 1}`,
                    type: roomType.type,
                    color: roomType.color,
                    position: { x, y: 0, z },
                    size: { width: roomWidth, height: roomHeight, depth: roomDepth },
                    area: `${(roomWidth * roomDepth).toFixed(1)}ã¡`,
                    status: Math.random() > 0.3 ? 'âœ… ä½¿ç”¨ä¸­' : 'ğŸŸ¢ ç©ºé—²'
                };
            }
            
            updateLoadingProgress(30, 'æ­£åœ¨åˆ›å»º3Dæ¨¡å‹...');
            
            // ä½¿ç”¨åˆå¹¶å‡ ä½•ä½“ä¼˜åŒ–ï¼ˆæ€§èƒ½æå‡å…³é”®ï¼ï¼‰
            if (OPTIMIZATION_CONFIG.useMergedGeometry) {
                createMergedRooms();
            } else {
                createIndividualRooms();
            }
            
            const endTime = performance.now();
            console.log(`âœ… ç”Ÿæˆå®Œæˆï¼è€—æ—¶: ${(endTime - startTime).toFixed(2)}ms`);
            
            updateLoadingProgress(100, 'å®Œæˆï¼');
            updateStats();
        }

        function createMergedRooms() {
            // åˆå¹¶æ‰€æœ‰æˆ¿é—´åˆ°ä¸€ä¸ªå‡ ä½•ä½“ï¼ˆå·¨å¤§çš„æ€§èƒ½æå‡ï¼ï¼‰
            const geometries = [];
            const colors = [];
            
            Object.values(roomData).forEach((room, index) => {
                const { position, size, color } = room;
                
                // åˆ›å»ºåœ°æ¿
                const floorGeo = new THREE.BoxGeometry(size.width, 0.2, size.depth);
                floorGeo.translate(position.x, 0.1, position.z);
                geometries.push(floorGeo);
                
                // æ·»åŠ é¢œè‰²
                const colorObj = new THREE.Color(color);
                const positionCount = floorGeo.attributes.position.count;
                for (let i = 0; i < positionCount; i++) {
                    colors.push(colorObj.r, colorObj.g, colorObj.b);
                }
                
                // åˆ›å»ºå¢™å£
                const wallHeight = size.height;
                const wallThickness = 0.15;
                
                // å‰å¢™
                const frontWall = new THREE.BoxGeometry(size.width, wallHeight, wallThickness);
                frontWall.translate(position.x, wallHeight / 2, position.z + size.depth / 2);
                geometries.push(frontWall);
                for (let i = 0; i < frontWall.attributes.position.count; i++) {
                    colors.push(0.8, 0.8, 0.8);
                }
                
                // åå¢™
                const backWall = new THREE.BoxGeometry(size.width, wallHeight, wallThickness);
                backWall.translate(position.x, wallHeight / 2, position.z - size.depth / 2);
                geometries.push(backWall);
                for (let i = 0; i < backWall.attributes.position.count; i++) {
                    colors.push(0.8, 0.8, 0.8);
                }
                
                // å·¦å¢™
                const leftWall = new THREE.BoxGeometry(wallThickness, wallHeight, size.depth);
                leftWall.translate(position.x - size.width / 2, wallHeight / 2, position.z);
                geometries.push(leftWall);
                for (let i = 0; i < leftWall.attributes.position.count; i++) {
                    colors.push(0.8, 0.8, 0.8);
                }
                
                // å³å¢™
                const rightWall = new THREE.BoxGeometry(wallThickness, wallHeight, size.depth);
                rightWall.translate(position.x + size.width / 2, wallHeight / 2, position.z);
                geometries.push(rightWall);
                for (let i = 0; i < rightWall.attributes.position.count; i++) {
                    colors.push(0.8, 0.8, 0.8);
                }
                
                if (index % 10 === 0) {
                    const progress = 30 + (index / Object.keys(roomData).length) * 60;
                    updateLoadingProgress(progress, `åˆ›å»ºæˆ¿é—´ ${index + 1}/${Object.keys(roomData).length}...`);
                }
            });
            
            // åˆå¹¶æ‰€æœ‰å‡ ä½•ä½“
            updateLoadingProgress(90, 'åˆå¹¶å‡ ä½•ä½“...');
            const mergedGeometry = mergeGeometries(geometries);
            
            // æ·»åŠ é¡¶ç‚¹é¢œè‰²
            mergedGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            // åˆ›å»ºæè´¨
            const material = new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.7,
                metalness: 0.2,
                flatShading: false
            });
            
            // åˆ›å»ºåˆå¹¶çš„ç½‘æ ¼
            mergedMesh = new THREE.Mesh(mergedGeometry, material);
            mergedMesh.castShadow = false;
            mergedMesh.receiveShadow = false;
            scene.add(mergedMesh);
            
            console.log(`âœ… ä½¿ç”¨åˆå¹¶å‡ ä½•ä½“ä¼˜åŒ–ï¼Œ${Object.keys(roomData).length} ä¸ªæˆ¿é—´åˆå¹¶ä¸º 1 ä¸ªç½‘æ ¼ï¼`);
        }

        // ç®€å•çš„å‡ ä½•ä½“åˆå¹¶å‡½æ•°ï¼ˆå…¼å®¹ç‰ˆï¼‰
        function mergeGeometries(geometries) {
            // ç›´æ¥è¿”å›ç¬¬ä¸€ä¸ªå‡ ä½•ä½“ä½œä¸ºåŸºç¡€ï¼Œç„¶åæ‰‹åŠ¨åˆå¹¶
            // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–ç‰ˆæœ¬ï¼Œé€‚ç”¨äºæ²¡æœ‰ BufferGeometryUtils çš„æƒ…å†µ
            
            if (geometries.length === 0) return new THREE.BufferGeometry();
            if (geometries.length === 1) return geometries[0];
            
            // è®¡ç®—æ€»é¡¶ç‚¹æ•°
            let totalVertices = 0;
            let totalIndices = 0;
            
            geometries.forEach(geo => {
                totalVertices += geo.attributes.position.count;
                if (geo.index) {
                    totalIndices += geo.index.count;
                }
            });
            
            // åˆ›å»ºåˆå¹¶åçš„ç¼“å†²åŒº
            const positions = new Float32Array(totalVertices * 3);
            const indices = totalIndices > 0 ? new Uint32Array(totalIndices) : null;
            
            let vertexOffset = 0;
            let indexOffset = 0;
            let indexBase = 0;
            
            geometries.forEach(geo => {
                const posAttr = geo.attributes.position;
                
                // å¤åˆ¶é¡¶ç‚¹ä½ç½®
                for (let i = 0; i < posAttr.count; i++) {
                    const offset = (vertexOffset + i) * 3;
                    positions[offset] = posAttr.getX(i);
                    positions[offset + 1] = posAttr.getY(i);
                    positions[offset + 2] = posAttr.getZ(i);
                }
                
                // å¤åˆ¶ç´¢å¼•
                if (geo.index && indices) {
                    for (let i = 0; i < geo.index.count; i++) {
                        indices[indexOffset + i] = geo.index.getX(i) + indexBase;
                    }
                    indexOffset += geo.index.count;
                }
                
                indexBase += posAttr.count;
                vertexOffset += posAttr.count;
            });
            
            // åˆ›å»ºåˆå¹¶çš„å‡ ä½•ä½“
            const mergedGeo = new THREE.BufferGeometry();
            mergedGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            if (indices) {
                mergedGeo.setIndex(new THREE.BufferAttribute(indices, 1));
            }
            
            // è‡ªåŠ¨è®¡ç®—æ³•çº¿ï¼ˆå¦‚æœåŸå‡ ä½•ä½“æ²¡æœ‰æ³•çº¿ï¼‰
            mergedGeo.computeVertexNormals();
            
            return mergedGeo;
        }

        function createIndividualRooms() {
            // ä¼ ç»Ÿæ–¹å¼ï¼šä¸ºæ¯ä¸ªæˆ¿é—´åˆ›å»ºå•ç‹¬çš„meshï¼ˆè¾ƒæ…¢ï¼‰
            Object.values(roomData).forEach((room, index) => {
                const roomGroup = createRoomMesh(room);
                scene.add(roomGroup);
                rooms.push(roomGroup);
                
                if (index % 5 === 0) {
                    const progress = 30 + (index / Object.keys(roomData).length) * 60;
                    updateLoadingProgress(progress, `åˆ›å»ºæˆ¿é—´ ${index + 1}/${Object.keys(roomData).length}...`);
                }
            });
        }

        function createRoomMesh(room) {
            const { position, size, color } = room;
            const roomGroup = new THREE.Group();
            roomGroup.userData = { id: room.id, data: room };
            
            const floorGeo = new THREE.BoxGeometry(size.width, 0.2, size.depth);
            const floorMat = new THREE.MeshStandardMaterial({ color: color });
            const floorMesh = new THREE.Mesh(floorGeo, floorMat);
            roomGroup.add(floorMesh);
            
            roomGroup.position.set(position.x, position.y, position.z);
            return roomGroup;
        }

        function getRandomRoomType() {
            const rand = Math.random();
            let cumulative = 0;
            for (const type of ROOM_TYPES) {
                cumulative += type.probability;
                if (rand < cumulative) return type;
            }
            return ROOM_TYPES[0];
        }

        function clearRooms() {
            rooms.forEach(room => scene.remove(room));
            rooms = [];
            if (mergedMesh) {
                scene.remove(mergedMesh);
                mergedMesh.geometry.dispose();
                mergedMesh.material.dispose();
                mergedMesh = null;
            }
        }

        function regenerateRooms() {
            const count = parseInt(document.getElementById('roomCountInput').value) || 100;
            if (count < 10 || count > OPTIMIZATION_CONFIG.maxRooms) {
                alert(`æˆ¿é—´æ•°é‡åº”åœ¨ 10 åˆ° ${OPTIMIZATION_CONFIG.maxRooms} ä¹‹é—´`);
                return;
            }
            document.getElementById('loading').style.display = 'block';
            setTimeout(() => {
                generateRooms(count);
                document.getElementById('loading').style.display = 'none';
            }, 100);
        }

        function updateLoadingProgress(percent, text) {
            document.getElementById('loadingProgress').style.width = percent + '%';
            document.getElementById('loadingText').textContent = text;
        }

        // ==================== äº¤äº’ ====================
        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            
            if (mergedMesh) {
                const intersects = raycaster.intersectObject(mergedMesh);
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const closestRoom = findClosestRoom(point);
                    if (closestRoom) {
                        showRoomInfo(closestRoom);
                    }
                }
            } else {
                const intersects = raycaster.intersectObjects(rooms, true);
                if (intersects.length > 0) {
                    let clickedRoom = intersects[0].object;
                    while (clickedRoom.parent && !clickedRoom.userData.id) {
                        clickedRoom = clickedRoom.parent;
                    }
                    if (clickedRoom.userData.data) {
                        showRoomInfo(clickedRoom.userData.data);
                    }
                }
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function findClosestRoom(point) {
            let closest = null;
            let minDist = Infinity;
            
            Object.values(roomData).forEach(room => {
                const dx = point.x - room.position.x;
                const dz = point.z - room.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);
                
                if (dist < minDist && dist < room.size.width / 2) {
                    minDist = dist;
                    closest = room;
                }
            });
            
            return closest;
        }

        function showRoomInfo(room) {
            document.getElementById('infoTitle').textContent = `${room.id} - ${room.name}`;
            
            let infoHTML = `
                <div class="info-item">
                    <div class="info-label">ç±»å‹</div>
                    <div class="info-value">${room.type}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">é¢ç§¯</div>
                    <div class="info-value">${room.area}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">çŠ¶æ€</div>
                    <div class="info-value">${room.status}</div>
                </div>
                <div class="info-item">
                    <div class="info-label">ä½ç½®</div>
                    <div class="info-value">X: ${room.position.x.toFixed(1)}, Z: ${room.position.z.toFixed(1)}</div>
                </div>
            `;
            
            document.getElementById('infoContent').innerHTML = infoHTML;
            document.getElementById('infoPanel').classList.add('show');
        }

        function performSearch() {
            const searchTerm = document.getElementById('searchInput').value.trim().toUpperCase();
            if (!searchTerm) return;
            
            const room = roomData[searchTerm];
            if (room) {
                // é£åˆ°ç›®æ ‡æˆ¿é—´
                const targetPos = new THREE.Vector3(room.position.x, 20, room.position.z + 15);
                animateCamera(camera.position, targetPos, new THREE.Vector3(room.position.x, 0, room.position.z));
                setTimeout(() => showRoomInfo(room), 1000);
            } else {
                alert('æœªæ‰¾åˆ°æˆ¿é—´: ' + searchTerm);
            }
        }

        function animateCamera(from, to, lookAt) {
            const duration = 1500;
            const startTime = Date.now();
            const startFrom = from.clone();
            const startLookAt = controls.target.clone();
            
            function update() {
                const now = Date.now();
                const progress = Math.min((now - startTime) / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startFrom, to, eased);
                controls.target.lerpVectors(startLookAt, lookAt, eased);
                controls.update();
                
                if (progress < 1) {
                    requestAnimationFrame(update);
                }
            }
            update();
        }

        // UIæ§åˆ¶
        function resetCamera() {
            animateCamera(camera.position, new THREE.Vector3(60, 50, 60), new THREE.Vector3(0, 0, 0));
        }

        function toggleWireframe() {
            showWireframe = !showWireframe;
            if (mergedMesh) {
                mergedMesh.material.wireframe = showWireframe;
            }
            rooms.forEach(room => {
                room.children.forEach(child => {
                    if (child.material) child.material.wireframe = showWireframe;
                });
            });
        }

        function toggleHints() {
            const hints = document.getElementById('hints');
            hints.style.display = hints.style.display === 'none' ? 'block' : 'none';
        }

        function closeInfoPanel() {
            document.getElementById('infoPanel').classList.remove('show');
        }

        function flyThroughRooms() {
            if (flyThroughActive) {
                flyThroughActive = false;
                return;
            }
            
            flyThroughActive = true;
            const roomList = Object.values(roomData);
            let index = 0;
            
            function flyNext() {
                if (!flyThroughActive || index >= roomList.length) {
                    flyThroughActive = false;
                    return;
                }
                
                const room = roomList[index];
                const targetPos = new THREE.Vector3(room.position.x, 15, room.position.z + 10);
                animateCamera(camera.position, targetPos, new THREE.Vector3(room.position.x, 0, room.position.z));
                
                index++;
                setTimeout(flyNext, 2000);
            }
            
            flyNext();
        }

        // æ€§èƒ½ç»Ÿè®¡
        let lastTime = Date.now();
        let frames = 0;

        function updateStats() {
            document.getElementById('roomCount').textContent = Object.keys(roomData).length;
            document.getElementById('objects').textContent = scene.children.length;
            
            if (renderer.info && renderer.info.render) {
                const triangles = renderer.info.render.triangles;
                document.getElementById('triangles').textContent = triangles.toLocaleString();
            }
            
            if (performance.memory) {
                const memory = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
                document.getElementById('memory').textContent = memory;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            renderer.render(scene, camera);
            
            // æ›´æ–°FPS
            frames++;
            const now = Date.now();
            if (now - lastTime >= 1000) {
                document.getElementById('fps').textContent = frames;
                updateStats();
                frames = 0;
                lastTime = now;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // å¯åŠ¨
        init();
        console.log('ğŸ® é«˜æ€§èƒ½3Då¹³é¢å›¾ç³»ç»Ÿå·²å¯åŠ¨ï¼');
        console.log('âš¡ ä¼˜åŒ–ç‰¹æ€§:');
        console.log('  - åˆå¹¶å‡ ä½•ä½“: ', OPTIMIZATION_CONFIG.useMergedGeometry);
        console.log('  - é˜´å½±: ', OPTIMIZATION_CONFIG.enableShadows);
        console.log('  - æ”¯æŒæˆ¿é—´æ•°: ', OPTIMIZATION_CONFIG.maxRooms);
    </script>
</body>
</html>

